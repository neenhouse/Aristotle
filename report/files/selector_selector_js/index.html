<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - selector/selector.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>selector/selector.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">45.39</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">428</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">65.89</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.42</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var chars = jQuery.browser.safari &amp;&amp; parseInt(jQuery.browser.version) &lt; 417 ?
		&quot;(?:[\\w*_-]|\\\\.)&quot; :
		&quot;(?:[\\w\u0128-\uFFFF*_-]|\\\\.)&quot;,
	quickChild = new RegExp(&quot;^&gt;\\s*(&quot; + chars + &quot;+)&quot;),
	quickID = new RegExp(&quot;^(&quot; + chars + &quot;+)(#)(&quot; + chars + &quot;+)&quot;),
	quickClass = new RegExp(&quot;^([#.]?)(&quot; + chars + &quot;*)&quot;);

jQuery.extend({
	expr: {
		&quot;&quot;: &quot;m[2]==&#039;*&#039;||jQuery.nodeName(a,m[2])&quot;,
		&quot;#&quot;: &quot;a.getAttribute(&#039;id&#039;)==m[2]&quot;,
		&quot;:&quot;: {
			// Position Checks
			lt: &quot;i&lt;m[3]-0&quot;,
			gt: &quot;i&gt;m[3]-0&quot;,
			nth: &quot;m[3]-0==i&quot;,
			eq: &quot;m[3]-0==i&quot;,
			first: &quot;i==0&quot;,
			last: &quot;i==r.length-1&quot;,
			even: &quot;i%2==0&quot;,
			odd: &quot;i%2&quot;,

			// Child Checks
			&quot;first-child&quot;: &quot;a.parentNode.getElementsByTagName(&#039;*&#039;)[0]==a&quot;,
			&quot;last-child&quot;: &quot;jQuery.nth(a.parentNode.lastChild,1,&#039;previousSibling&#039;)==a&quot;,
			&quot;only-child&quot;: &quot;!jQuery.nth(a.parentNode.lastChild,2,&#039;previousSibling&#039;)&quot;,

			// Parent Checks
			parent: &quot;a.firstChild&quot;,
			empty: &quot;!a.firstChild&quot;,

			// Text Check
			contains: &quot;(a.textContent||a.innerText||&#039;&#039;).indexOf(m[3])&gt;=0&quot;,

			// Visibility
			visible: &#039;&quot;hidden&quot;!=a.type&amp;&amp;jQuery.css(a,&quot;display&quot;)!=&quot;none&quot;&amp;&amp;jQuery.css(a,&quot;visibility&quot;)!=&quot;hidden&quot;&#039;,
			hidden: &#039;&quot;hidden&quot;==a.type||jQuery.css(a,&quot;display&quot;)==&quot;none&quot;||jQuery.css(a,&quot;visibility&quot;)==&quot;hidden&quot;&#039;,

			// Form attributes
			enabled: &quot;!a.disabled&quot;,
			disabled: &quot;a.disabled&quot;,
			checked: &quot;a.checked&quot;,
			selected: &quot;a.selected||jQuery.attr(a,&#039;selected&#039;)&quot;,

			// Form elements
			text: &quot;&#039;text&#039;==a.type&quot;,
			radio: &quot;&#039;radio&#039;==a.type&quot;,
			checkbox: &quot;&#039;checkbox&#039;==a.type&quot;,
			file: &quot;&#039;file&#039;==a.type&quot;,
			password: &quot;&#039;password&#039;==a.type&quot;,
			submit: &quot;&#039;submit&#039;==a.type&quot;,
			image: &quot;&#039;image&#039;==a.type&quot;,
			reset: &quot;&#039;reset&#039;==a.type&quot;,
			button: &#039;&quot;button&quot;==a.type||jQuery.nodeName(a,&quot;button&quot;)&#039;,
			input: &quot;/input|select|textarea|button/i.test(a.nodeName)&quot;,

			// :has()
			has: &quot;jQuery.find(m[3],a).length&quot;,

			// :header
			header: &quot;/h\\d/i.test(a.nodeName)&quot;
		}
	},
	
	// The regular expressions that power the parsing engine
	parse: [
		// Match: [@value=&#039;test&#039;], [@foo]
		/^(\[) *@?([\w-]+) *([!*$^~=]*) *(&#039;?&quot;?)(.*?)\4 *\]/,

		// Match: :contains(&#039;foo&#039;)
		/^(:)([\w-]+)\(&quot;?&#039;?(.*?(\(.*?\))?[^(]*?)&quot;?&#039;?\)/,

		// Match: :even, :last-chlid, #id, .class
		new RegExp(&quot;^([:.#]*)(&quot; + chars + &quot;+)&quot;)
	],

	multiFilter: function( expr, elems, not ) {
		var old, cur = [];

		while ( expr &amp;&amp; expr != old ) {
			old = expr;
			var f = jQuery.filter( expr, elems, not );
			expr = f.t.replace(/^\s*,\s*/, &quot;&quot; );
			cur = not ? elems = f.r : jQuery.merge( cur, f.r );
		}

		return cur;
	},

	find: function( t, context ) {
		// Quickly handle non-string expressions
		if ( typeof t != &quot;string&quot; )
			return [ t ];

		// Make sure that the context is a DOM Element
		if ( context &amp;&amp; !context.nodeType )
			context = null;

		// Set the correct context (if none is provided)
		context = context || document;

		// Initialize the search
		var ret = [context], done = [], last;

		// Continue while a selector expression exists, and while
		// we&#039;re no longer looping upon ourselves
		while ( t &amp;&amp; last != t ) {
			var r = [];
			last = t;

			t = jQuery.trim(t);

			var foundToken = false;

			// An attempt at speeding up child selectors that
			// point to a specific element tag
			var re = quickChild;
			var m = re.exec(t);

			if ( m ) {
				var nodeName = m[1].toUpperCase();

				// Perform our own iteration and filter
				for ( var i = 0; ret[i]; i++ )
					for ( var c = ret[i].firstChild; c; c = c.nextSibling )
						if ( c.nodeType == 1 &amp;&amp; (nodeName == &quot;*&quot; || c.nodeName.toUpperCase() == nodeName.toUpperCase()) )
							r.push( c );

				ret = r;
				t = t.replace( re, &quot;&quot; );
				if ( t.indexOf(&quot; &quot;) == 0 ) continue;
				foundToken = true;
			} else {
				re = /^([&gt;+~])\s*(\w*)/i;

				if ( (m = re.exec(t)) != null ) {
					r = [];

					var nodeName = m[2], mergeNum = jQuery.mergeNum++;
					m = m[1];

					for ( var j = 0, rl = ret.length; j &lt; rl; j++ ) {
						var n = m == &quot;~&quot; || m == &quot;+&quot; ? ret[j].nextSibling : ret[j].firstChild;
						for ( ; n; n = n.nextSibling )
							if ( n.nodeType == 1 ) {
								if ( m == &quot;~&quot; &amp;&amp; n.mergeNum == mergeNum ) break;
								
								if (!nodeName || n.nodeName.toUpperCase() == nodeName.toUpperCase() ) {
									if ( m == &quot;~&quot; ) n.mergeNum = mergeNum;
									r.push( n );
								}
								
								if ( m == &quot;+&quot; ) break;
							}
					}

					ret = r;

					// And remove the token
					t = jQuery.trim( t.replace( re, &quot;&quot; ) );
					foundToken = true;
				}
			}

			// See if there&#039;s still an expression, and that we haven&#039;t already
			// matched a token
			if ( t &amp;&amp; !foundToken ) {
				// Handle multiple expressions
				if ( !t.indexOf(&quot;,&quot;) ) {
					// Clean the result set
					if ( context == ret[0] ) ret.shift();

					// Merge the result sets
					done = jQuery.merge( done, ret );

					// Reset the context
					r = ret = [context];

					// Touch up the selector string
					t = &quot; &quot; + t.substr(1,t.length);

				} else {
					// Optimize for the case nodeName#idName
					var re2 = quickID;
					var m = re2.exec(t);
					
					// Re-organize the results, so that they&#039;re consistent
					if ( m ) {
					   m = [ 0, m[2], m[3], m[1] ];

					} else {
						// Otherwise, do a traditional filter check for
						// ID, class, and element selectors
						re2 = quickClass;
						m = re2.exec(t);
					}

					m[2] = m[2].replace(/\\/g, &quot;&quot;);

					var elem = ret[ret.length-1];

					// Try to do a global search by ID, where we can
					if ( m[1] == &quot;#&quot; &amp;&amp; elem &amp;&amp; elem.getElementById &amp;&amp; !jQuery.isXMLDoc(elem) ) {
						// Optimization for HTML document case
						var oid = elem.getElementById(m[2]);
						
						// Do a quick check for the existence of the actual ID attribute
						// to avoid selecting by the name attribute in IE
						// also check to insure id is a string to avoid selecting an element with the name of &#039;id&#039; inside a form
						if ( (jQuery.browser.msie||jQuery.browser.opera) &amp;&amp; oid &amp;&amp; typeof oid.id == &quot;string&quot; &amp;&amp; oid.id != m[2] )
							oid = jQuery(&#039;[@id=&quot;&#039;+m[2]+&#039;&quot;]&#039;, elem)[0];

						// Do a quick check for node name (where applicable) so
						// that div#foo searches will be really fast
						ret = r = oid &amp;&amp; (!m[3] || jQuery.nodeName(oid, m[3])) ? [oid] : [];
					} else {
						// We need to find all descendant elements
						for ( var i = 0; ret[i]; i++ ) {
							// Grab the tag name being searched for
							var tag = m[1] == &quot;#&quot; &amp;&amp; m[3] ? m[3] : m[1] != &quot;&quot; || m[0] == &quot;&quot; ? &quot;*&quot; : m[2];

							// Handle IE7 being really dumb about &lt;object&gt;s
							if ( tag == &quot;*&quot; &amp;&amp; ret[i].nodeName.toLowerCase() == &quot;object&quot; )
								tag = &quot;param&quot;;

							r = jQuery.merge( r, ret[i].getElementsByTagName( tag ));
						}

						// It&#039;s faster to filter by class and be done with it
						if ( m[1] == &quot;.&quot; )
							r = jQuery.classFilter( r, m[2] );

						// Same with ID filtering
						if ( m[1] == &quot;#&quot; ) {
							var tmp = [];

							// Try to find the element with the ID
							for ( var i = 0; r[i]; i++ )
								if ( r[i].getAttribute(&quot;id&quot;) == m[2] ) {
									tmp = [ r[i] ];
									break;
								}

							r = tmp;
						}

						ret = r;
					}

					t = t.replace( re2, &quot;&quot; );
				}

			}

			// If a selector string still exists
			if ( t ) {
				// Attempt to filter it
				var val = jQuery.filter(t,r);
				ret = r = val.r;
				t = jQuery.trim(val.t);
			}
		}

		// An error occurred with the selector;
		// just return an empty set instead
		if ( t )
			ret = [];

		// Remove the root context
		if ( ret &amp;&amp; context == ret[0] )
			ret.shift();

		// And combine the results
		done = jQuery.merge( done, ret );

		return done;
	},

	classFilter: function(r,m,not){
		m = &quot; &quot; + m + &quot; &quot;;
		var tmp = [];
		for ( var i = 0; r[i]; i++ ) {
			var pass = (&quot; &quot; + r[i].className + &quot; &quot;).indexOf( m ) &gt;= 0;
			if ( !not &amp;&amp; pass || not &amp;&amp; !pass )
				tmp.push( r[i] );
		}
		return tmp;
	},

	filter: function(t,r,not) {
		var last;

		// Look for common filter expressions
		while ( t  &amp;&amp; t != last ) {
			last = t;

			var p = jQuery.parse, m;

			for ( var i = 0; p[i]; i++ ) {
				m = p[i].exec( t );

				if ( m ) {
					// Remove what we just matched
					t = t.substring( m[0].length );

					m[2] = m[2].replace(/\\/g, &quot;&quot;);
					break;
				}
			}

			if ( !m )
				break;

			// :not() is a special case that can be optimized by
			// keeping it out of the expression list
			if ( m[1] == &quot;:&quot; &amp;&amp; m[2] == &quot;not&quot; )
				r = jQuery.filter(m[3], r, true).r;

			// We can get a big speed boost by filtering by class here
			else if ( m[1] == &quot;.&quot; )
				r = jQuery.classFilter(r, m[2], not);

			else if ( m[1] == &quot;[&quot; ) {
				var tmp = [], type = m[3];
				
				for ( var i = 0, rl = r.length; i &lt; rl; i++ ) {
					var a = r[i], z = a[ jQuery.props[m[2]] || m[2] ];
					
					if ( z == null || /href|src|selected/.test(m[2]) )
						z = jQuery.attr(a,m[2]) || &#039;&#039;;

					if ( (type == &quot;&quot; &amp;&amp; !!z ||
						 type == &quot;=&quot; &amp;&amp; z == m[5] ||
						 type == &quot;!=&quot; &amp;&amp; z != m[5] ||
						 type == &quot;^=&quot; &amp;&amp; z &amp;&amp; !z.indexOf(m[5]) ||
						 type == &quot;$=&quot; &amp;&amp; z.substr(z.length - m[5].length) == m[5] ||
						 (type == &quot;*=&quot; || type == &quot;~=&quot;) &amp;&amp; z.indexOf(m[5]) &gt;= 0) ^ not )
							tmp.push( a );
				}
				
				r = tmp;

			// We can get a speed boost by handling nth-child here
			} else if ( m[1] == &quot;:&quot; &amp;&amp; m[2] == &quot;nth-child&quot; ) {
				var num = jQuery.mergeNum++, tmp = [],
					test = /(\d*)n\+?(\d*)/.exec(
						m[3] == &quot;even&quot; &amp;&amp; &quot;2n&quot; || m[3] == &quot;odd&quot; &amp;&amp; &quot;2n+1&quot; ||
						!/\D/.test(m[3]) &amp;&amp; &quot;n+&quot; + m[3] || m[3]),
					first = (test[1] || 1) - 0, last = test[2] - 0;

				for ( var i = 0, rl = r.length; i &lt; rl; i++ ) {
					var node = r[i], parentNode = node.parentNode;

					if ( num != parentNode.mergeNum ) {
						var c = 1;

						for ( var n = parentNode.firstChild; n; n = n.nextSibling )
							if ( n.nodeType == 1 )
								n.nodeIndex = c++;

						parentNode.mergeNum = num;
					}

					var add = false;

					if ( first == 1 ) {
						if ( last == 0 || node.nodeIndex == last )
							add = true;
					} else if ( (node.nodeIndex + last) % first == 0 )
						add = true;

					if ( add ^ not )
						tmp.push( node );
				}

				r = tmp;

			// Otherwise, find the expression to execute
			} else {
				var f = jQuery.expr[m[1]];
				if ( typeof f != &quot;string&quot; )
					f = jQuery.expr[m[1]][m[2]];

				// Build a custom macro to enclose it
				f = eval(&quot;false||function(a,i){return &quot; + f + &quot;}&quot;);

				// Execute it against the current filter
				r = jQuery.grep( r, f, not );
			}
		}

		// Return an array of filtered elements (r)
		// and the modified expression string (t)
		return { r: r, t: t };
	},

	parents: function( elem ){
		var matched = [];
		var cur = elem.parentNode;
		while ( cur &amp;&amp; cur != document ) {
			matched.push( cur );
			cur = cur.parentNode;
		}
		return matched;
	},
	
	nth: function(cur,result,dir,elem){
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] )
			if ( cur.nodeType == 1 &amp;&amp; ++num == result )
				break;

		return cur;
	},
	
	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType == 1 &amp;&amp; (!elem || n != elem) )
				r.push( n );
		}

		return r;
	}
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
